name: iOS Production Build (Local - No EAS Credits)

on:
  workflow_dispatch: {}  # Manual trigger only

env:
  NODE_VERSION: '20'

jobs:
  build-ios-local:
    name: Build iOS IPA Locally (No EAS Credits)
    runs-on: macos-latest
    timeout-minutes: 90
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history

      - name: ðŸ” Verify project structure
        run: |
          echo "Verifying project structure..."
          ls -la | head -20
          if [ -f "package-lock.json" ]; then
            echo "âœ… package-lock.json found"
          else
            echo "âŒ package-lock.json not found"
            exit 1
          fi

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          # Using v3 to avoid auto-caching issues in v4

      - name: ðŸ”§ Install dependencies
        run: npm ci

      - name: ðŸš€ Setup Expo CLI
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: ðŸ“± Prebuild iOS project
        run: |
          echo "Generating native iOS project..."
          npx expo prebuild --platform ios --clean
        env:
          EXPO_PUBLIC_SUPABASE_URL: ${{ secrets.EXPO_PUBLIC_SUPABASE_URL }}
          EXPO_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.EXPO_PUBLIC_SUPABASE_ANON_KEY }}

      - name: ðŸ” Setup Code Signing
        run: |
          echo "Setting up code signing..."
          echo "Using automatic signing - Xcode will manage certificates and profiles"
          echo "Team ID: ${{ secrets.APPLE_TEAM_ID }}"
          
          # Create keychain for code signing (if needed)
          security create-keychain -p "" build.keychain || true
          security set-keychain-settings -t 3600 -u build.keychain || true
          security default-keychain -s build.keychain || true
          
          # Unlock keychain
          security unlock-keychain -p "" build.keychain || true
          
          echo "Keychain setup complete"
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: ðŸ“ Create Export Options
        run: |
          echo "Creating exportOptions.plist..."
          cat > ios/exportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store-connect</string>
              <key>teamID</key>
              <string>${{ secrets.APPLE_TEAM_ID }}</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>compileBitcode</key>
              <false/>
              <key>signingStyle</key>
              <string>automatic</string>
          </dict>
          </plist>
          EOF
          echo "Export options created"

      - name: ðŸ”§ Fix Podfile Code Signing
        working-directory: ./ios
        run: |
          echo "Fixing Podfile to disable code signing for Pods..."
          
          if [ ! -f "Podfile" ]; then
            echo "Error: Podfile not found"
            exit 1
          fi
          
          # Debug: Show Podfile structure
          echo "=== Podfile Debug Info ==="
          echo "Podfile exists: $(test -f Podfile && echo 'YES' || echo 'NO')"
          echo "Podfile size: $(wc -l < Podfile) lines"
          echo "Searching for post_install patterns:"
          grep -n "post_install" Podfile | head -5 || echo "No post_install found"
          echo "=========================="
          
          # Backup Podfile
          cp Podfile Podfile.backup
          
          # Check if code signing settings already exist - if yes, skip entirely
          if grep -q "CODE_SIGN_IDENTITY" Podfile && grep -q "CODE_SIGNING_REQUIRED" Podfile; then
            echo "Code signing settings already present, skipping..."
            exit 0
          fi
          
          # Check if post_install hook exists (allow for indentation)
          # Look for "post_install do" anywhere in the line, not just at start
          POST_INSTALL_LINE=$(grep -n "post_install do" Podfile | head -1 | cut -d: -f1)
          
          if [ -z "$POST_INSTALL_LINE" ]; then
            echo "WARNING: post_install hook not found, creating new one at end of Podfile..."
            # Create new post_install hook at the end
            echo "" >> Podfile
            echo "post_install do |installer|" >> Podfile
            echo "  # Disable code signing for Pods" >> Podfile
            echo "  installer.pods_project.targets.each do |target|" >> Podfile
            echo "    target.build_configurations.each do |config|" >> Podfile
            echo "      config.build_settings['CODE_SIGN_IDENTITY'] = ''" >> Podfile
            echo "      config.build_settings['CODE_SIGNING_REQUIRED'] = 'NO'" >> Podfile
            echo "      config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'" >> Podfile
            echo "      config.build_settings['CODE_SIGN_STYLE'] = 'Manual'" >> Podfile
            echo "    end" >> Podfile
            echo "  end" >> Podfile
            echo "end" >> Podfile
          else
            echo "Found existing post_install hook at line $POST_INSTALL_LINE, adding code signing settings..."
            # Create temp file with code signing block
            echo "  # Disable code signing for Pods" > /tmp/code_signing_insert.txt
            echo "  installer.pods_project.targets.each do |target|" >> /tmp/code_signing_insert.txt
            echo "    target.build_configurations.each do |config|" >> /tmp/code_signing_insert.txt
            echo "      config.build_settings['CODE_SIGN_IDENTITY'] = ''" >> /tmp/code_signing_insert.txt
            echo "      config.build_settings['CODE_SIGNING_REQUIRED'] = 'NO'" >> /tmp/code_signing_insert.txt
            echo "      config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'" >> /tmp/code_signing_insert.txt
            echo "      config.build_settings['CODE_SIGN_STYLE'] = 'Manual'" >> /tmp/code_signing_insert.txt
            echo "    end" >> /tmp/code_signing_insert.txt
            echo "  end" >> /tmp/code_signing_insert.txt
            
            # Find the line with react_native_post_install (always present in expo prebuild)
            REACT_NATIVE_LINE=$(grep -n "react_native_post_install" Podfile | head -1 | cut -d: -f1)
            if [ -n "$REACT_NATIVE_LINE" ]; then
              echo "Found react_native_post_install at line $REACT_NATIVE_LINE"
              # Find the closing ')' of the react_native_post_install function call
              # Use awk to find first line after react_native_post_install that ends with just ')'
              INSERT_LINE=$(awk -v start="$REACT_NATIVE_LINE" 'NR > start && /^[[:space:]]*\)[[:space:]]*$/ {print NR; exit}' Podfile)
              
              if [ -z "$INSERT_LINE" ]; then
                # Fallback: if no closing ) found, insert 5 lines after react_native_post_install
                # (react_native_post_install usually spans 3-4 lines)
                INSERT_LINE=$((REACT_NATIVE_LINE + 5))
                echo "WARNING: Could not find closing ')' for react_native_post_install, inserting at line $INSERT_LINE"
              else
                echo "Found closing ')' at line $INSERT_LINE, inserting after it..."
              fi
              # Insert temp file content after the closing parenthesis
              sed -i.bak "${INSERT_LINE}r /tmp/code_signing_insert.txt" Podfile
              rm -f /tmp/code_signing_insert.txt
            else
              echo "WARNING: react_native_post_install not found, inserting before last 'end'..."
              # Fallback: find the last 'end' at start of line and insert before it
              LAST_END_LINE=$(grep -n "^end$" Podfile | tail -1 | cut -d: -f1)
              if [ -n "$LAST_END_LINE" ]; then
                echo "Found last 'end' at line $LAST_END_LINE, inserting before it..."
                sed -i.bak "${LAST_END_LINE}r /tmp/code_signing_insert.txt" Podfile
              else
                echo "ERROR: Could not find insertion point!"
                rm -f /tmp/code_signing_insert.txt
                exit 1
              fi
              rm -f /tmp/code_signing_insert.txt
            fi
          fi
          
          echo ""
          echo "=== Verification ==="
          echo "Number of 'post_install do' declarations:"
          grep -c "post_install do" Podfile || echo "0"
          echo ""
          echo "Last 30 lines of Podfile:"
          tail -30 Podfile

      - name: ðŸ“¦ Install CocoaPods dependencies
        working-directory: ./ios
        run: |
          echo "Installing CocoaPods dependencies..."
          echo "Verifying Podfile has post_install hook:"
          grep -A 10 "post_install" Podfile || echo "WARNING: post_install not found!"
          sudo gem install cocoapods
          pod install --repo-update

      - name: ðŸ” Find Xcode Scheme
        working-directory: ./ios
        run: |
          echo "Finding Xcode scheme..."
          WORKSPACE=$(find . -name "*.xcworkspace" | head -1)
          if [ -z "$WORKSPACE" ]; then
            echo "Error: No .xcworkspace found"
            exit 1
          fi
          
          echo "Workspace: $WORKSPACE"
          
          # Get the actual app project name (not Pods)
          APP_PROJECT=$(find . -name "*.xcodeproj" -not -path "*/Pods/*" | head -1)
          if [ -z "$APP_PROJECT" ]; then
            echo "Error: No app project found"
            exit 1
          fi
          
          echo "App project: $APP_PROJECT"
          
          # List schemes from the app project (not workspace, to avoid Pods schemes)
          ALL_SCHEMES=$(xcodebuild -list -project "$APP_PROJECT" 2>/dev/null | grep -A 20 "Schemes:" | grep -v "Schemes:" | grep -v "^--" | grep -v "^$" | xargs)
          echo "App schemes: $ALL_SCHEMES"
          
          # Try to find scheme matching app name
          SCHEME=$(echo "$ALL_SCHEMES" | tr ' ' '\n' | grep -i "flex\|aura" | head -1 | xargs || echo "")
          
          # If not found, use first scheme from app project
          if [ -z "$SCHEME" ] || [ "$SCHEME" = "" ]; then
            SCHEME=$(echo "$ALL_SCHEMES" | tr ' ' '\n' | head -1 | xargs || echo "")
          fi
          
          # Final fallback
          if [ -z "$SCHEME" ] || [ "$SCHEME" = "" ]; then
            SCHEME="FlexAura"
            echo "Using default scheme: $SCHEME"
          fi
          
          echo "âœ… Selected scheme: $SCHEME"
          echo "SCHEME_NAME=$SCHEME" >> $GITHUB_ENV

      - name: ðŸ—ï¸ Build Archive with Xcode
        working-directory: ./ios
        run: |
          echo "Building iOS archive..."
          
          # Find workspace
          WORKSPACE=$(find . -name "*.xcworkspace" | head -1)
          echo "Using workspace: $WORKSPACE"
          
          # Create build directory
          mkdir -p ./build
          
          # Build archive with absolute path
          ARCHIVE_PATH="$(pwd)/build/flex-aura.xcarchive"
          echo "Archive will be created at: $ARCHIVE_PATH"
          
          # Check available signing identities
          echo "=== Available Signing Identities ==="
          security find-identity -v -p codesigning || echo "No identities found"
          echo ""
          
          # Build for iOS device (not simulator)
          # Use automatic signing - Xcode will handle certificate selection
          set -o pipefail
          xcodebuild clean archive \
            -workspace "$WORKSPACE" \
            -scheme "${{ env.SCHEME_NAME }}" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$ARCHIVE_PATH" \
            -allowProvisioningUpdates \
            DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGN_STYLE="Automatic" \
            2>&1 | tee /tmp/xcodebuild.log
          
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "âŒ Archive build failed with exit code: $BUILD_EXIT_CODE"
            echo "=== Full error output ==="
            echo "Last 100 lines of build log:"
            tail -100 /tmp/xcodebuild.log
            echo ""
            echo "=== Searching for errors ==="
            grep -i "error\|failed\|fatal" /tmp/xcodebuild.log | tail -50
            echo ""
            echo "=== Build summary ==="
            grep -i "archive\|succeeded\|failed" /tmp/xcodebuild.log | tail -10
            exit $BUILD_EXIT_CODE
          fi
          
          # Verify archive exists
          if [ -d "$ARCHIVE_PATH" ]; then
            echo "âœ… Archive created successfully at: $ARCHIVE_PATH"
            echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> $GITHUB_ENV
          else
            echo "âŒ Archive not found at: $ARCHIVE_PATH"
            echo "Listing build directory:"
            ls -la ./build/ || echo "Build directory doesn't exist"
            exit 1
          fi

      - name: ðŸ” Setup Certificates and Profiles for Export
        run: |
          echo "Setting up certificates and provisioning profiles for export..."
          
          # Create keychain for storing credentials
          security create-keychain -p "" build.keychain || true
          security set-keychain-settings -t 3600 -u build.keychain || true
          security default-keychain -s build.keychain || true
          security unlock-keychain -p "" build.keychain || true
          
          # Install EAS CLI
          npm install -g eas-cli
          
          # Pull iOS credentials from EAS (doesn't use build credits, just downloads them)
          echo "Pulling iOS credentials from EAS..."
          echo "This downloads certificates and provisioning profiles without using build credits"
          
          # Use EAS credentials API to get credentials
          eas credentials --platform ios --non-interactive --skip-credentials-check || {
            echo "âš ï¸ Note: If credentials don't exist in EAS, they need to be created first"
            echo "Run locally: eas credentials --platform ios"
            echo "Then commit and push, and this will work"
          }
          
          # List available certificates
          echo "=== Available Signing Certificates ==="
          security find-identity -v -p codesigning | grep -i "distribution\|apple" || echo "No distribution certificates found"
          
          # List provisioning profiles
          echo "=== Available Provisioning Profiles ==="
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles/
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ 2>/dev/null | head -5 || echo "No provisioning profiles directory found"
          
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: ðŸ“¦ Export IPA
        working-directory: ./ios
        run: |
          echo "Exporting IPA from archive..."
          
          # Use the archive path from previous step
          ARCHIVE_PATH="${{ env.ARCHIVE_PATH }}"
          if [ -z "$ARCHIVE_PATH" ]; then
            ARCHIVE_PATH="$(pwd)/build/flex-aura.xcarchive"
          fi
          
          echo "Looking for archive at: $ARCHIVE_PATH"
          
          # Verify archive exists
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "âŒ Archive not found at: $ARCHIVE_PATH"
            echo "Current directory: $(pwd)"
            echo "Listing ios directory:"
            ls -la
            echo "Listing build directory (if exists):"
            ls -la ./build/ 2>/dev/null || echo "Build directory doesn't exist"
            exit 1
          fi
          
          echo "âœ… Archive found, proceeding with export..."
          
          EXPORT_PATH="$(pwd)/build"
          
          # Export IPA with authentication
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist ./exportOptions.plist \
            -allowProvisioningUpdates
          
          echo "IPA exported successfully"
          
          # Find the IPA file
          IPA_FILE=$(find "$EXPORT_PATH" -name "*.ipa" | head -1)
          if [ -z "$IPA_FILE" ]; then
            echo "âŒ IPA file not found in $EXPORT_PATH"
            echo "Listing export directory:"
            ls -la "$EXPORT_PATH"
            exit 1
          fi
          
          echo "âœ… IPA file found: $IPA_FILE"
          echo "IPA_PATH=$IPA_FILE" >> $GITHUB_ENV

      - name: ðŸ“¤ Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-production-ipa
          path: ios/build/*.ipa
          retention-days: 30
          if-no-files-found: error

      - name: ðŸ“‹ Build Summary
        run: |
          echo "## âœ… iOS Build Complete (Local Build)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Your IPA has been built locally on GitHub Actions Mac runner." >> $GITHUB_STEP_SUMMARY
          echo "**âœ… No EAS Build credits were used!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the IPA from workflow artifacts (above)" >> $GITHUB_STEP_SUMMARY
          echo "2. Submit to App Store Connect:" >> $GITHUB_STEP_SUMMARY
          echo "   - Go to [App Store Connect](https://appstoreconnect.apple.com)" >> $GITHUB_STEP_SUMMARY
          echo "   - Upload the IPA manually, or" >> $GITHUB_STEP_SUMMARY
          echo "   - Use: \`eas submit --platform ios --path <ipa-file>\`" >> $GITHUB_STEP_SUMMARY
